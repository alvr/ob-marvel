# Marvel API

## Architecture

The application uses clean architecture, each layer separated in a different directory. This sample app has a `data remote`, `domain` and `ui` layers. If the application requires a database layer or preferences layer it can be created inside de `data` layer.

Each layer contains different features, each feature is a module in the corresponding layer. This speed up the building process because only the modules that have changed are compile whilst the untouched modules are cached.

The `data remote`, `domain` and `ui` layers have a `base` module that contains classes, functions, constants, etc. that may be required by the differents modules in the layer.

### Communication between layers

Following the SOLID principles, the abstractions are defined in the `domain` modules and the implementation in the corresponding `data` module. That means that if we have a `characters` feature, the abstraction should be defined in a module of the `domain` layer and the implementation of the repositories, API requests, mappers, etc. in the `data` layer.

The `classes`/`interfaces` in the `domain` modules must be `public` if they are used in a different module (i.e. `data` module or `ui` module). In the other hand the implementations in the `data` modules can be `internal` as their usage should be restricted to their own module because the abstraction should be used instead. This is the main point of **dependency injection**.

The application uses Hilt as dependency injection manager. Each `data` module should have a dependency injection module that binds the implementation with the abstraction. This way in the `domain` use cases we must inject the repository `interface` (the `domain` layer mustn't know about the implementations) and Hilt will inject the corresponding implementation.

To communicate between the `ui` layer and the `data` layer we use the use cases in the `domain` layer as a bridge. These use cases are injected in the `ViewModel`s and used when needed.

## Use Cases

They are two use cases:

1. Get the characters list by filter
2. Get character details

### Characters list

The first use case use the `paging` Android library that allows to request multiple pages from a data source (remote data source in this case) and emit all values using `Flow` that later will be collected in the `ui`.

The `FlowUseCase` connects the `Flow` returned by the `CharactersPagingSource` with the `ui` remains active as long as there is a collector. This collector is the `CharactersViewModel` in this case.

Is possible to filter by name all the characters. It will make a request 500ms after the user finish writing.

### Character details

The second one returns the details of a single character. Although the first use case also returns all the details of a character, is preferred to use the second use case because the details are not shown in the characters list and consume memory that can be used in other things. The simpler the model is, the less resources it uses.

## UI

The `ui` modules are made in Compose, that makes the development of simple apps faster and easier. Creating and reusing components is easier in Compose than the traditional XML.

Following the same architecture, each feature is a module in the `ui` layer and only the main content could be `public`, keeping the rest of the composables `internal` or `private`.

The `ViewModel`s can be injected in the composables with Hilt and the state can be observed so only the affected composables are recreated.

It uses the Compose navigation component to navigate from one screen to another, similar to the one for the traditional XML views.

### Characters list (UI)

As said before, the list of characters is exposed as a `Flow` generated by the `paging` Android library and cached in the `ViewModel` as long as it is active. This data is collected in the composable and propagated down in the ui tree.

The `paging` library allows us to show a loading indicator the first time the data is fetched and in the bottom of the list when fetching the next page. It is also posible to display a custom view when an error occurs and retry the failed page.

Because the characters list is quite long, a search filter is at the top right, so you can search characters that starts with that filter. The request is made 500ms after the user stops writing to avoid sequential requests every time the user enters/removes a character.

### Character details (UI)

When an user clicks on a character it will navigate to the details screen. The character `id` is passed to the navigation controller and can be retrieved in the `ViewModel` using `SavedStateHandle`. Because `SavedStateHandle` doesn't guaranteed that the data we are requesting is available, the `id` can be `null`. This leads us to the next point, and it is why we are using a `sealed class` to represent the view state.

Because `sealed classes` has restricted inheritance, is possible to define the possible states a view can have:

* `Uninitialized` the initial state. The view has not changed yet.
* `Loading` we are performing a task that may take some time, so is possible to display a loading icon.
* `Success` the task completed successfully and returned some data that the view will use.
* `Failure` something wrong happened executing a task, notify the view to show an error.

The state is collected in the view, because it is exposed as a `StateFlow`, that means that it will always have a state and every collector will receive the latest state.

Going back the the first paragraph, if is not possible to find the `id` or the server returns an error, the new state of the view will be `Failure` and the screen will show an error message and a button to try again the request.

If it can be found, then first the state will be `Loading` and the screen will have a loading spinner in the center. After getting the data and mapping it to a custom entity, the `Success` and the details of the character will be collected in the screen and displayed.

*PS: The design and architecture is based on [Katana](https://github.com/alvr/katana), one of my projects using Jetpack Compose.*
